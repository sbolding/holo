//NONE OF THIS CLASS REALLY WORKS YET, NOT SURE OF BEST WAY TO DO IT.  SHOULD PROBABLY
//HAVE THE HOSOLVER BE ABLE TO CALCULATE MU BARS ETC FOR CERTAIN MU AND SUCH AND PASS IN SCORES FOR CERTAIN TALLIES OR SOMETHING, RATHE
//THAN HAVIN GHTE HOSOLVER DO EVERYTHING
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : DataTransfer.cpp
//  @ Date : 2/7/2014
//  @ Author : 
//
//


#include "DataTransfer.h"

DataTransfer::DataTransfer(HoSolver* ho_solver, Mesh* mesh)
{
	_ho_solver = ho_solver;
	_mesh = mesh;
}

void DataTransfer::updateLoSystem()
{
	//Loop over elements in the mesh
	Element* current_element;
	LoData1D lo_data();
	
	for (int el = 0; el < _mesh->getNumElems(); ++el)
	{
		current_element = _mesh->getElement(el);
	//	current_element->setLoData(calculateLoData(lo_data, el));
	}
}

/*void DataTransfer::calculateLoData(LoData1D & lo_data, int element_id)
{
	//NOTE: all variables in this section are independent of the sources strength in the problem, 
	//not in general true
	//local variables to calculate	
	LoData1D lo_data;
	double alpha;
	double alpha_plus;
	double alpha_minus;
	AveragedCosines surf_cosines;
	AveragedCosines vol_cosines;

	//Calculate alpha based on phi left and phi right moments, and face flux value
	double phi_left_moment;
	double phi_right_moment;
	double left_face_value;
	double right_face_value;
	int left_face_id = _mesh->getFaceIndex(element_id, 0);
	int right_face_id = _mesh->getFaceIndex(element_id, 1);

	//based on relations between phi_zeta and phi_avg, can be derived from definition moments
	phi_right_moment = 2.*_ho_solver->_flux_element_tallies[element_id]->getScoreAngularIntegrated(_ho_solver->_n_histories, 1);
	phi_left_moment = 2.*(_ho_solver->_flux_element_tallies[element_id]->getScoreAngularIntegrated(_ho_solver->_n_histories, 0)) - phi_right_moment;
	left_face_value = _flux_face_tallies[_mesh->getFaceIndex(element_id, 0)]->getScoreAngularIntegrated(_ho_solver->_n_histories);
	right_face_value = _flux_face_tallies[_mesh->getFaceIndex(element_id, 1)]->getScoreAngularIntegrated(_n_histories);

	//calculate alpha plus and alpha minus
	alpha_plus = (right_face_value - phi_left_moment) / (phi_right_moment - phi_left_moment);
	alpha_minus = (left_face_value - phi_right_moment) / (phi_left_moment - phi_right_moment);

	//Assume alpha is average of these two for now, quite possibly totally wrong though
	alpha = 0.5*(alpha_plus + alpha_minus);
	lo_data.setSpatialClosureFactor(alpha);

	//Calculate the different surface cosines
	surf_cosines._mu_left_minus = _current_face_tallies[left_face_id]->getScore(_n_histories, 0) /
		//	lo_data.setSurfAveragedCos(surf_cosines);
		//lo_data.setVolAveragedCos(vol_cosines); 

		return lo_data;
} */
