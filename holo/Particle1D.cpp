//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  High Order Solver
//  @ File Name : Particle1D.cpp
//  @ Date : 1/27/2014
//  @ Author : Simon R Bolding
//
//

#include "Particle1D.h"
#include <iostream>
#include "Controller.h"

Particle1D::Particle1D(Mesh* mesh, RNG* rng, string method_str,
	std::vector<CurrentFaceTally*>& current_face_tallies,
	std::vector<CurrentElementTally*>& current_element_tallies,
	std::vector<FluxFaceTally*>& flux_face_tallies,
	std::vector<FluxElementTally*>& flux_element_tallies
	)
{
	_rng = rng;
	_mesh = mesh;
	_position_mfp = -999999999999.; //initialize outside teh domain to check that source samplign works correctly
	_n_elements = _mesh->getNumElems();
	_current_element = 0;	   //particle needs to be somewhere to initialize material properties
	updateElementProperties(); //intiialize to the material properties of the 0-th element, will likely change once sampling occurs, but must initialize
	_method = HoMethods::method_map.at(method_str);
	_is_dead = true;

	if (HoController::PARTICLE_BALANCE)
	{
		_n_abs = 0;
		_n_leak = 0;
		_n_scat = 0;
		_n_terminations=0;
	}

	//store the tallies correctly
	_current_face_tallies = current_face_tallies;
	_current_element_tallies = current_element_tallies;
	_flux_face_tallies = flux_face_tallies;
	_flux_element_tallies = flux_element_tallies;

	//Initialize the data needed for source sampling
	initializeSamplingSource();
}

inline double Particle1D::samplePathLength()
{
	return -1.*log(_rng->rand_num())*_mfp_tot;
}

inline double Particle1D::samplePathLengthMFP()
{
	return -1.*log(_rng->rand_num());
}

void Particle1D::sampleCollision()
{
	if (_is_dead)
	{
		return;
	}
	if ( (_method == HoMethods::HOLO_ECMC) || (_method == HoMethods::HOLO_STANDARD_MC) ) //then a pure absorber problem, end the history
	{
		terminateHistory();
		if (HoController::PARTICLE_BALANCE)
		{
			_n_abs++;
		}
	}
	else if (_method == HoMethods::STANDARD_MC) //usual MC sample which event, sample new direction if scattering
	{
		//determine if a scattering event
		if (_rng->rand_num() < _scat_ratio)
		{
			if (HoController::PARTICLE_BALANCE)
			{
				_n_scat++;
			}
			double mu_scat = sampleAngleIsotropic();
			//use angle addition to get the new scattered cosine
			_mu = _mu*mu_scat - sqrt(1. - mu_scat*mu_scat)*sqrt(1. - _mu*_mu);
		}
		else //Non scattering event
		{
			//TODO, if there were something besides absorption possible you would put it here
			terminateHistory();
			if (HoController::PARTICLE_BALANCE) //debug stuff
			{
				_n_abs++;
			}
		}
	}
	else	
	{
		std::cerr << "Input an incorrect mode of operation\n";
		exit(1);
	}

}

void Particle1D::sampleLinDiscontSource(std::vector<double> nodal_values)
{
	//Sample the position based on the nodal values, should write a function to get the area of the source from the element somehow

	//If this routine is too slow, do a soft check to see if they are different first, then do the check below
	if (abs(nodal_values[0] - nodal_values[1])/nodal_values[0] < 1.E-10) //then effectively a constant source, sampling is uniform across the cell
	{
		_position_mfp = _rng->rand_num()*_element_width_mfp;
	}
	else //need to sample from lin discontinuous source //THIS ROUTINE WORKS
	{
		double left_hat, right_hat; //Normalized nodal values, such that CDF is normalized
		left_hat = 2.0*nodal_values[0] / (nodal_values[1] + nodal_values[0]);
		right_hat = 2.0 - left_hat;
		//use direct inversion of CDF to sample position, based on quadratic formula
		_position_mfp = -left_hat + sqrt(left_hat*left_hat + 2 * _rng->rand_num()*(right_hat - left_hat));
		_position_mfp /= (right_hat - left_hat);
		_position_mfp *= _element_width_mfp; //convert to mfp
	}
}

void Particle1D::initializeSamplingSource()
{
	//get the area of the source, and the total external source nodal values
	std::vector<Element*>* elements;
	elements = _mesh->getElements();
	_source_strength_per_cell = new std::vector<double>();
	std::vector<Element*>::iterator it_el;  //element iterator
	it_el = elements->begin();				//initialize iterator
	double ext_source_el;					//magnitude of external source of curr element
	std::vector<double> total_src_nodal_values_el; 

	for (; it_el != elements->end(); it_el++)
	{
		//Initialize to the external source strength
		try
		{
			total_src_nodal_values_el = (*it_el)->getExtSourceNodalValues(); //initialize to ext source values
			if (_method == HoMethods::HOLO_ECMC || _method == HoMethods::HOLO_STANDARD_MC) //append scattering source
			{
				double sigma_s_el = (*it_el)->getMaterial().getSigmaS();
				std::vector<double> scat_src_nodal_values_el = (*it_el)->getScalarFluxNodalValues();//This should return 0 if LO system hasnt been solved yet
				if (scat_src_nodal_values_el.size() != total_src_nodal_values_el.size())
				{
					std::cerr << "Scattering source and external source do not have the same number of nodal values" << std::endl;
					exit(0);
				}
				for (int node = 0; node < scat_src_nodal_values_el.size(); node++)
				{
					total_src_nodal_values_el[node] += scat_src_nodal_values_el[node]* sigma_s_el; //phi*_sigma_s, note there is no 1/(4pi) here, because we want (p/sec)
				}				
			}
			ext_source_el = getTotalSourceMagnitude(total_src_nodal_values_el, (*it_el)->getElementDimensions()[0]);
			_total_src_nodal_values.push_back(total_src_nodal_values_el);
			_source_strength_per_cell->push_back(ext_source_el);
			_vol_src_total += ext_source_el;
		}
		catch (...)
		{
			std::cerr << "The HoSolver had trouble initialized because the Lo System was not properly initialized and not solved, in Particle1D" << std::endl;
			exit(1);
		}
	}

	if (HoController::SAMPLING_METHOD == 1) //standard source sampling
	{
		//Create sampler with alias sampling, let it normalize, delete unneccessary data
		_alias_sampler = new AliasSampler( (*_source_strength_per_cell), false);
		_source_strength_per_cell->clear();
		delete _source_strength_per_cell;
	}
	else
	{
		std::cerr << "No other samplilng methods are implemented yet" << std::endl;
		exit(1);
	}

	//Initially assume no BC source TODO
	_BC_src_total = 0.0;
}

inline double Particle1D::getTotalSourceMagnitude(std::vector<double> nodal_values, double element_volume)
{
	return 0.5*(nodal_values[0] + nodal_values[1])*element_volume;
}

void Particle1D::sampleSourceParticle()
{
	//Determine if it is volumetric source, or surface source (depending on the mode you are in, may sample scattering source as well)
	//Store the entire source (ext + scattering) into the other one and compute its area.  With the area you can easily determine if sample
	//is from isotropic source or if it is from 
	if (_rng->rand_num() < _vol_src_total / (_BC_src_total + _vol_src_total))
	{
		_current_element = _alias_sampler->sampleBin(_rng->rand_num(), _rng->rand_num()); //sample direction
		sampleLinDiscontSource(_total_src_nodal_values[_current_element]); //sample position TODO pull this out into MC utility class
		//sampleLinDiscontSource(_mesh->getElement(_current_element)->getExtSourceNodalValues()); //THIS MIGHT BE USEFUL IN A STANDARD MC CALC, but is essentially equivalent
	}
	else //Volumetric source
	{
		std::cerr << "Sampling of BC source is not yet implemented" << std::endl;
		exit(1);
	}
	
	//Assume all sources have isotropic angular distribution TODO this will need to be updated for the case of boundary sources, just add over
	//loaded function for sampleAngleIsotropic that takes a start and end range of angle to be allowed in and adjusts weight accordingly
	_mu = sampleAngleIsotropic();

	//Update particle properties for the new cell
	updateElementProperties();

	//Test it out
	std::vector<int> scores;
	scores.assign(_n_elements, 0);
	for (int i = 0; i < 500000; ++i)
	{
		_current_element = _alias_sampler->sampleBin(_rng->rand_num(),_rng->rand_num());
		scores[_current_element] += 1;
	}
	for (int i = 0; i < _n_elements; ++i)
	{
		cout << "Score: " << scores[i] << endl;
	}

	system("pause");
}

//May not need this function if doesn't do more later
inline void Particle1D::initializeHistory()
{
	_weight = 1.0;
	_is_dead = false;
}

inline double Particle1D::sampleAngleIsotropic()
{
	return _rng->rand_num()*2.0 - 1.;
}

void Particle1D::leaveElement()
{
	scoreFaceTally(); //Score the surface tally, based on the current face
	//Contribute to tallies, determine which element you are entering
	if ( (_mu >= 0.0) && (_current_element < (_n_elements-1)) ) //stream to the cell to the right
	{
		_current_element++; //move to the right one cell	
		updateElementProperties();
		_position_mfp = 0.0; //at the left edge of the new cell
		
	}
	else if( (_mu < 0.0) && (_current_element > 0) ) //stream to the cell to the left
	{
		_current_element--;
		updateElementProperties();
		_position_mfp = _element_width_mfp; //particle is at right edge of the new cell
	}
	else //particle has left the problem domain
	{
		//cout << "I have leaked from element " << _current_element << endl;
		if (HoController::PARTICLE_BALANCE)
		{
			_n_leak++;
		}
		terminateHistory();
	}
}

void Particle1D::runHistory()
{
	//TODO need to pull the streaming stuff out into its own function again so it will be easier to implement the derived classes
	//cout << "starting history..." << endl;
	//start history
	initializeHistory(); //Reset the basic parameters
	sampleSourceParticle();

	double path_length_mfp;  
	double displacement_mfp;
	double new_position_mfp;

	while (true) //stream the particle until it is absorbed or leaks
	{
		//sample a pathlength
		path_length_mfp = samplePathLengthMFP();

		//determine horizontal displacement
		displacement_mfp = path_length_mfp*_mu;
		new_position_mfp = displacement_mfp + _position_mfp;

		//determine if the particle has left the cell, or not
		while ((new_position_mfp < 0.) || (new_position_mfp > _element_width_mfp)) //particle has left the cell
		{
			//tally variables, corresponding to path across current cell
			double path_start = _position_mfp; 
			double path_end;

			//Determine the number of mean free paths remaining to stream after entering new cell
			if (_mu >= 0.0) //streaming to the right
			{
				displacement_mfp += (_position_mfp - _element_width_mfp);
				path_end = _element_width_mfp; //leaves to the right
			}
			else //streaming to the left
			{
				displacement_mfp += _position_mfp;
				path_end = 0.0; //leaves to the left
			}
			scoreElementTally(path_start, path_end);
			leaveElement(); //move to the next element

			if (_is_dead) //then particle has leaked, do not score anything else
			{
				return;
			}
			new_position_mfp = _position_mfp + displacement_mfp; //determine where the particle would be now
		}

		//Now position is within the current cell
		scoreElementTally(_position_mfp, new_position_mfp);
		_position_mfp = new_position_mfp;
		sampleCollision();
		if (_is_dead)
		{
			return;
		}
	} //end of outer history while loop
}

//return random numbers for use by source or whoever needs one
inline double Particle1D::getRandNum()
{
	return _rng->rand_num();
}

//for when particle has entered a new cell need to update the properties to the current cell
void Particle1D::updateElementProperties()
{
	Element* element = _mesh->getElement(_current_element);
	_element_width_mfp = _mfp_tot*element->getElementDimensions()[0]; //always need to update the width in general
	if (element->getMaterialID() == _element_mat_ID)
	{
		return; //no need to update
	}
	else
	{
		MaterialConstant mat;
		mat = element->getMaterial();
		_sigma_tot = mat.getSigmaT();
		_mfp_tot = 1. / _sigma_tot;
		_sigma_scat = mat.getSigmaS();
		_sigma_abs = mat.getSigmaA();
		_element_mat_ID = element->getMaterialID();
		//Set the material data
		if (_method == HoMethods::HOLO_ECMC || _method == HoMethods::HOLO_STANDARD_MC) //pure absorber problem, maybe?
		{
			_scat_ratio = 0.0;
		}
		else
		{
			_scat_ratio = _sigma_scat / _sigma_tot;
		}
	}

}

void Particle1D::scoreElementTally(double path_start_mfp, double path_end_mfp)
{
	//Score Element tally, need to convert path_length and volume
	//to cm, rather than mfp
	//int _elem_id = _current_element;
	double path_length_cm = abs((path_start_mfp - path_end_mfp)*_mfp_tot/_mu);
	double volume_cm = _element_width_mfp*_mfp_tot;//*1.0cm*1.0cm = h_x(cm^3)
	double normalized_position = 0.5*(path_start_mfp+path_end_mfp)/_element_width_mfp;
	
	//increment tallies
	_current_element_tallies[_current_element]->incrementScore(_weight,
		path_length_cm, _mu, volume_cm, normalized_position); 
	_flux_element_tallies[_current_element]->incrementScore(_weight,
		path_length_cm, _mu, volume_cm, normalized_position);
}

inline void Particle1D::scoreFaceTally()
{
	//The face tally is scored before you have left the cell, so everything is
	//based on the cell you are leaving, not the cell you are entering

	//determine face based on direction
	int face_id = 0; //Leaving to the left
	if (_mu >= 0.0) //Leaving to the right
	{
		face_id = 1;
	}

	//increment the correct tallies
	int face_index = _mesh->getFaceIndex(_current_element,face_id);
	_current_face_tallies[face_index]->incrementScore(_weight, _mu, 1.0); //for one-d, per cm sq
	_flux_face_tallies[face_index]->incrementScore(_weight, _mu, 1.0);
}

inline void Particle1D::terminateHistory()
{
	//TODO may need to do other stuff here
	if (HoController::PARTICLE_BALANCE)
	{
		_n_terminations++;
	}
	_is_dead = true;
}

void Particle1D::printParticleBalance(int n_hist)
{
	cout << "---------------------------------------------------\n"
		<< "               Particle balance\n"
		<< "---------------------------------------------------\n\n"
		<< "	 Number Created: " << n_hist << endl
		<< "	Number Absorbed: " << _n_abs << endl
		<< "      Number Leaked: " << _n_leak << endl
		<< "    Number Scatters: " << _n_scat << endl
		<< "  Number Terminated: " << _n_terminations << endl;	
}