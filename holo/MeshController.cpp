//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : MeshController.cpp
//  @ Date : 2/23/2014
//  @ Author : SRB
//
//


#include "MeshController.h"
#include <cmath>

MeshController::MeshController(HoMesh* mesh, double exp_conv_constant, int n_batches_to_check):
	_required_conv_rate(exp_conv_constant),
	_mesh(mesh), 
	_n_batches_to_check(n_batches_to_check),
	_batch_residual_norms()
{
	createConnectivityArray();
}

void MeshController::computeJumpError()
{
	//loop over active elements
	//compute the jump integral for each face (that has an adjacent cell)
}

void MeshController::createConnectivityArray()
{
	//loop over elements
	std::vector<ECMCElement1D*>* elements = _mesh->getElements();
	std::vector<ECMCElement1D*>::iterator it_el;
	for (it_el = elements->begin(); it_el != elements->end(); it_el++)
	{
		//TODO create the connectivity array
	}
}

void MeshController::storeResidualNorm(double residual_norm)
{
	if (_batch_residual_norms.size() == (_n_batches_to_check+1)) //one extra since you need ratios to check refinement
	{
		_batch_residual_norms.erase(_batch_residual_norms.begin()); //remove the oldest element
	}
	_batch_residual_norms.push_back(residual_norm);
}

void MeshController::refineMesh()
{
	//Refine mesh
	refineElement(1);
	refineElement(0);
	refineElement(2);
	refineElement(4);
	refineElement(7);




	//update the connectivity array




	//reset convergence rate criteria
	_batch_residual_norms.erase(_batch_residual_norms.begin(), _batch_residual_norms.end() - 1); //clear all but the last one

}

bool MeshController::meshNeedsRefinement()
{
	if (_batch_residual_norms.size() != (_n_batches_to_check + 1))
	{
		return false; //not enough batches to check convergence, because of noise
	}
	else
	{
		double alpha_avg = 0.0;
		for (int i = 0; i < _n_batches_to_check; ++i) //loop over batches
		{
			alpha_avg += std::log(_batch_residual_norms[i] / _batch_residual_norms[i+1]);
		}
		alpha_avg /= (float)_n_batches_to_check;

		//check convergence
		if (alpha_avg < _required_conv_rate) //if error increases, alpha will be negative and go back up
		{
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MeshController::refineElement(int element_id)
{
	//probably better to have this function return the new elements made
	ECMCElement1D* unrefined_element = _mesh->_elements[element_id];
	std::vector<ECMCElement1D*> new_elements;
	_mesh->getElement(element_id)->refine(_mesh->_n_elems - 1); //pass the id of last element made

	//add the new elements to the list and update number of elements
	new_elements = _mesh->getElement(element_id)->getChildren();
	_mesh->_elements.insert(_mesh->_elements.end(), new_elements.begin(), new_elements.end());
	_mesh->_n_elems += new_elements.size();

	//determine if the refined cell was on a boundary
	std::vector<int>::iterator it_bound;
	it_bound = std::find(_mesh->_boundary_cells.begin(), _mesh->_boundary_cells.end(), element_id);
	if (it_bound != _mesh->_boundary_cells.end()) 
	{
		_mesh->_boundary_cells_need_update = true; //created cell was on a boundary, update boundary cells
		_mesh->findUpwindBoundaryCells(); //update the boundary list, won't cost any extra to do it now rather than later
		return; //no upwind boundary poitners to update
	}
	
	//Update pointers to the refined element if necessary
	ECMCElement1D* upstream_el = _mesh->findJustUpwindElement(element_id);
	if (upstream_el->getRefinementLevel() == new_elements[0]->getRefinementLevel()) 
	{
		//the upstraem element is of same refinement, need to set the other daughter too
		if (upstream_el->getAngularCoordinate() < unrefined_element->getAngularCoordinate()) //found bottom (minus mu) refined cell
		{
			upstream_el->setDownStreamElement(new_elements[1]);
			upstream_el = _mesh->findJustUpwindElement(new_elements[3]->getID()); //get the top cell
			upstream_el->setDownStreamElement(new_elements[3]); //set the top cells ds element
		}
		else //you found the top (plus mu) refined cell
		{
			//This case is not normally called, but it works and may happen in the event of round off
			upstream_el->setDownStreamElement(new_elements[3]);
			upstream_el = _mesh->findJustUpwindElement(new_elements[1]->getID());
			upstream_el->setDownStreamElement(new_elements[1]);
		}
	}
	else if (upstream_el->getRefinementLevel() == unrefined_element->getRefinementLevel()) 
	{
		if (upstream_el->hasChildren())
		{
			std::cerr << "I dont know why this would ever be called, in MeshController.cpp" << std::endl;
			exit(1);
			upstream_el->getChild(0)->setDownStreamElement(new_elements[1]);
			upstream_el->getChild(2)->setDownStreamElement(new_elements[3]);
		}
		else
		{
			//no ds elem pnters to update
			return;
		}
	}
}