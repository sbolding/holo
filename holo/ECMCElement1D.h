//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : ECMCElement1D.h
//  @ Date : 2/10/2014
//  @ Author : 
//
//


#if !defined(_ECMCELEMENT1D_H)
#define _ECMCELEMENT1D_H

#include "ECMCElement.h"

class ECMCElement1D : public ECMCElement
{
protected:

	//references for easy use in 1D calculations
	double & _psi_average;	    //Average flux, ALL FLUXES CURRENTLY HAVE UNITS OF PER SOURCE PARTICLE
	double & _psi_x;			//Moment in x direction
	double & _psi_mu;			//Moment in mu direction
	double & _width_spatial;	//delta_x, in cm
	double & _width_angle;		//delta_mu
	double & _position_center;	//x_i (center of element in x)
	double & _mu_center;		//mu_i (center of element in mu)
	ECMCElement1D();			//don't call me

	//Pointer to the downstream element (different for positive and negative flow)
	ECMCElement1D* _down_stream_element;

	//For adaptive mesh refinement, this can be done in the super class once more generalized, should be easy to move
	std::vector<ECMCElement1D*> _children; //a list of the children elements created for mesh refinement

public:
	ECMCElement1D(int id, Element* element, ECMCElement1D* down_stream_element, std::vector<double> dimensions, std::vector<double> coordinates);

	//methods only used by Particle1D
	virtual ECMCElement1D* getDownStreamElement() const;
	double getAngularWidth() const;	//width of element in angle
	double getSpatialWidth() const; //width of element in x
	double getAngularCoordinate() const; //center of element in angle
	double getSpatialCoordinate() const; //center of element in x
	void incrementTallyScores(double weight, double path_length_cm, double dir_cosine,
		double normalized_position); //call appropriate code to increment the tally scores, normalized position is unitless

	//virtual methods
	virtual void printAngularFluxDOF(std::ostream & out) const;
	virtual void computeAngularFLuxDOF(int n_histories, double ext_src_str = 1.0);

	//adaptive refinement methods
	virtual void refine();

};
#endif  //_ECMCELEMENT1D_H
