// 
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : HoMesh.cpp
//  @ Date : 2/10/2014
//  @ Author : 
//
//


#include "HoMesh.h"

HoMesh::HoMesh(Mesh* lo_mesh, int n_ang_cells_half_range)
{
	//Local variables
	std::vector<Element*>* spatial_elements;
	spatial_elements = lo_mesh->getElements();
	std::vector<Element*>::iterator it_el;          //element iterator
	it_el = spatial_elements->begin();

	//TODO this is an angular connectivity array, currently not used, but correctly constructed
	std::vector<std::vector<int>> connectivity_array;
	connectivity_array.resize(lo_mesh->getNumElems());


	//create the number of angular elements needed for both half ranges
	if (lo_mesh->getSpatialDimension() == 1)
	{
		//Local dimensions to pass into element constructors
		std::vector<double> dimensions, coordinates;
		std::vector<double> nodal_locations; //edge node values
		dimensions.resize(2);
		coordinates.resize(2);
		double mu_center = 0.0; //the center of each element in mu
		double x_center = 0.0;  // the center of each element in x
		
		//all angular widths are the same before refinement
		dimensions[1] = 1. / (double)n_ang_cells_half_range;

		//create the elments for negative flow direction first, currently makes in reverse order because it is easiest
		for (int i_ang = 0; i_ang < n_ang_cells_half_range; i_ang++)
		{
			//Loop over the lo mesh elements
			for (; it_el != spatial_elements->end(); it_el++)
			{
				//determine dimensions for the element
				dimensions[0] = (*it_el)->getElementDimensions()[0]; //width_x
				x_center += dimensions[0] * 0.5; //move the center forward each time
				coordinates[0] = x_center;
				mu_center += dimensions[1] * 0.5;
				coordinates[1] = mu_center;

				if (it_el == spatial_elements->end() - 1)
				{

				}
				_elements.push_back(new ECMCElement1D(*it_el, dimensions, coordinates));
			}



		}

	}
	else
	{
		std::cerr << "Multi dimension not implemented for HoMesh constructor\n";
		system("pause");
		exit(1);
	}



	_n_elems = _elements.size();
}

ECMCElement* HoMesh::getElement(int element_id) const
{
	return _elements[element_id];
}

int HoMesh::getNumElems() const
{
	return _n_elems;
}

std::vector<ECMCElement* >* HoMesh::getElements(void)
{
	return &_elements; //pointer, be careful not to change these values
}
